import { AccountUpdate, Authorization } from './account-update.js';
import { AccountId, GenericState, TokenId } from './core.js';
import { AuthorizationLevel } from './permissions.js';
import { Field } from '../../provable/field.js'
import { Int64 } from '../../provable/int.js'
import { PrivateKey } from '../../provable/crypto/signature.js';
import { Types } from '../../../bindings/mina-transaction/types.js';
import { jsLayout } from '../../../bindings/mina-transaction/gen/js-layout.js';
import { Test } from '../../../snarky.js';
import { expect } from 'expect';

let mlTest = await Test();

let key = PrivateKey.random();
let address = key.toPublicKey();

function createAccountUpdate(): Promise<AccountUpdate.Authorized> {
  const accountUpdate = new AccountUpdate(GenericState, {
    authorizationKind: Authorization.AccountUpdate.Kind.None(),
    accountId: new AccountId(address, TokenId.MINA),
    verificationKeyHash: new Field(0),
    callData: new Field(0),
    callDepth: 0,
    balanceChange: Int64.from(1e9).neg()
  });

  return accountUpdate.authorize({
    networkId: 'testnet',
    getPrivateKey: async (_addr) => {
      throw new Error('unexpected call');
      // assert(addr.equals(address).toBoolean());
      // return key;
    },
    getTxnCallForestCommitment: () => {
      throw new Error('unexpected call');
    },
    getTxnFullCommitment: () => {
      throw new Error('unexpected call');
    }
  });
}

// can convert account update to JSON consistently
{
  let accountUpdate = await createAccountUpdate();

  let json1 = JSON.stringify(accountUpdate.toJSON());
  let json2 = JSON.stringify(Types.AccountUpdate.toJSON(accountUpdate.toInternalRepr()));
  console.log(json1);
  console.log(json2);
  expect(JSON.parse(json1)).toEqual(JSON.parse(json2));
}

// can convert account update to fields consistently
{
  const MinaTypes: {[key: string]: number} = {
    string: 0,
    number: 0,

    AuthRequired: 3,
    Bool: 1,
    Field: 1,
    PublicKey: 2,
    Int64: 2,
    Sign: 1,
    TokenId: 1,
    UInt32: 1,
    UInt64: 1
  };

  AuthorizationLevel.sizeInFields()

  interface JsLayout {
    type: string;
    checkedType?: JsLayout;

    // "object" properties
    name?: string;
    // TODO: could type this better if I cared
    keys?: string[];
    entries?: {[key: string]: JsLayout};

    // "option" properties
    optionType?: string,

    // "array" properties
    staticLength?: number | null,

    // "option" and "array" properties
    inner?: JsLayout
  }

  jsLayout satisfies {[key: string]: JsLayout};

  // TODO: should probably just be a loop, not a recursive function
  function fetchObjectPath(obj: {[key: string]: any}, path: string[], i: number = 0): any {
    if(i >= path.length) throw new Error('internal error');
    const key = path[i];

    if(!(key in obj)) throw new Error(`path not found: ${JSON.stringify(path)} (${key} not in ${JSON.stringify(obj)})`);

    const value = obj[key];
    console.log(`${i} (${key}) = ${JSON.stringify(value)}`);

    if(i === path.length-1) {
      return value;
    } else if(typeof value === 'object') {
      return fetchObjectPath(value, path, i+1);
    } else {
      throw new Error(`path not found: ${JSON.stringify(path)} (encounted non-object before traversing full path)`);
    }
  }

  // NB: a single mutable path reference is shared throughout recursive invocations of this function
  function crawlLayout(layout: JsLayout, dynamicSizes: object, f: (path: string[], type: string, sizeInFields: number) => void, initPath?: string[]) {
    // coerce default value here instead of with default arg to allocate a new array on each root invocation of this function
    const path = initPath ?? [];

    const enterKey = (key: string, l: JsLayout) => {
      path.push(key);
      crawlLayout(l, dynamicSizes, f, path);
      path.pop();
    }

    if(layout.checkedType !== undefined) {
      crawlLayout(layout.checkedType, dynamicSizes, f, path);
    } else {
      if(layout.type === 'object') {
        if(layout.entries === undefined || layout.keys === undefined) {
          throw new Error('invalid js layout format');
        }

        for(let key of layout.keys) {
          enterKey(key, layout.entries[key])
        }
      } else if(layout.type === 'array') {
        if(layout.inner === undefined || layout.staticLength === undefined) {
          throw new Error('invalid js layout format');
        }

        let length: number;
        if(layout.staticLength === null) {
          const fetchedLength = fetchObjectPath(dynamicSizes, path);
          if(typeof fetchedLength !== 'number') {
            throw new Error(`invalid js layout dynamic size information at path ${JSON.stringify(path)}: ${JSON.stringify(fetchedLength)}`);
          }
          length = fetchedLength;
        } else {
          length = layout.staticLength;
        }

        for(let i = 0; i < length; i++) {
          enterKey(`[${i}]`, layout.inner);
        }
      } else if(layout.type === 'option') {
        if(layout.optionType === undefined || layout.inner === undefined) {
          throw new Error('invalid js layout format');
        }

        if(layout.optionType === 'flaggedOption') {
          enterKey("isSome", { type: 'Bool' });
          enterKey("value", layout.inner);
        } else {
          crawlLayout(layout.inner, dynamicSizes, f, path);
        }
      } else {
        if(!(layout.type in MinaTypes)) {
          throw new Error(`unknown layout type: ${layout.type}`);
        }

        const sizeInFields = MinaTypes[layout.type];
        f([...path], layout.type, sizeInFields);
      }
    }
  }

  function layoutSizeInFields(layout: JsLayout, dynamicSizes: object): number {
    console.log(`dyanamicSizes = ${JSON.stringify(dynamicSizes)}`)

    let totalSize = 0;
    crawlLayout(layout, dynamicSizes, (_path, _type, size) => {totalSize += size});
    return totalSize;
  }

  let accountUpdate = await createAccountUpdate();

  // convert accountUpdate to fields in OCaml, going via AccountUpdate.of_json
  let json = JSON.stringify(accountUpdate.toJSON().body);
  let [, ...fields1_] = mlTest.fieldsFromJson.accountUpdate(json);
  let fields1 = fields1_.map((f) => new Field(f));
  // convert accountUpdate to fields in pure JS, leveraging generated code
  let fields2 = Types.AccountUpdate.toFields(accountUpdate.toInternalRepr());

  expect(fields1.length).toEqual(fields2.length);
  const layoutSize = layoutSizeInFields(jsLayout.AccountUpdate, {
    body: {
      events: { data: accountUpdate.pushEvents.length },
      actions: { data: accountUpdate.pushActions.length },
    }
  });
  expect(fields1.length).toEqual(layoutSize);
  expect(fields2.length).toEqual(layoutSize);

  // this is useful console output in the case the test should fail
  // if (fields1.length !== fields2.length) {
  //   console.log(
  //     `unequal length. expected ${fields1.length}, actual: ${fields2.length}`
  //   );
  // }
  // for (let i = 0; i < fields1.length; i++) {
  //   if (fields1[i].toString() !== fields2[i].toString()) {
  //     console.log('unequal at', i);
  //     console.log(`expected: ${fields1[i]} actual: ${fields2[i]}`);
  //   }
  // }

  expect(fields1.map(String)).toEqual(fields2.map(String));
  expect(fields1).toEqual(fields2);
}

/*
// can hash an account update
{
  let accountUpdate = createAccountUpdate();

  let hash = accountUpdate.hash();

  // if we clone the accountUpdate, hash should be the same
  let accountUpdate2 = AccountUpdate.clone(accountUpdate);
  expect(accountUpdate2.hash()).toEqual(hash);

  // if we change something on the cloned accountUpdate, the hash should become different
  AccountUpdate.setValue(accountUpdate2.update.appState[0], Field(1));
  expect(accountUpdate2.hash()).not.toEqual(hash);
}

// converts account update to a public input that's consistent with the ocaml implementation
{
  let otherAddress = PrivateKey.random().toPublicKey();

  let accountUpdate = AccountUpdate.create(address);
  let otherUpdate = AccountUpdate.create(otherAddress);
  accountUpdate.approve(otherUpdate);

  let publicInput = accountUpdate.toPublicInput({
    accountUpdates: [accountUpdate, otherUpdate],
  });

  // create transaction JSON with the same accountUpdate structure, for ocaml version
  let tx = await Mina.transaction(async () => {
    let accountUpdate = AccountUpdate.create(address);
    accountUpdate.approve(AccountUpdate.create(otherAddress));
  });
  let publicInputOcaml = mlTest.hashFromJson.zkappPublicInput(tx.toJSON(), 0);

  expect(publicInput).toEqual({
    accountUpdate: Field(publicInputOcaml.accountUpdate),
    calls: Field(publicInputOcaml.calls),
  });
}

// creates the right empty sequence state
{
  let accountUpdate = createAccountUpdate();
  expect(
    accountUpdate.body.preconditions.account.actionState.value.toString()
  ).toEqual(
    '25079927036070901246064867767436987657692091363973573142121686150614948079097'
  );
}

// creates the right empty vk hash
{
  let accountUpdate = createAccountUpdate();
  expect(
    accountUpdate.body.authorizationKind.verificationKeyHash.toString()
  ).toEqual(mocks.dummyVerificationKeyHash);
}
*/
